### 悲观锁

悲观锁的特点是先获取锁，再进行业务操作。每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，开始就默认会出现事物并发问题，所以在进行每次操作数据时都要通过获取锁才能进行对相同数据的操作，悲观锁需要耗费较多的时间，处理并发问题也相对严谨，在核心业务的关键之处可使用悲观锁，开销相对来说大。

悲观锁解决方案：在读取数据时将数据锁定，加排他锁，不允许其他线程读取和修改数据，直到存库修改完成释放锁

```sql
#开始事物
select id,productid,stock from zproduct where id=? for update;
update zproduct set stock=stock-? where id=?;
#结束事物
```

### 乐观锁

乐观锁是在遇到事物并发问题时，想法很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，认为这次的操作不会导致冲突，当出现事物并发问题时再处理。乐观锁由于加锁少，所以性能开销比较小，吞吐量大。

实现方法：给商品添加一个version字段，代码行修改版本号，读取库存是拿到这个version版本号，在更新时再对比version版本号，如果版本号相同，说明库存没有被其他线程修改过，可以正常操作，同时把version数值加1。如果版本号不同，代表被别的线程修改过，则取消修改库存操作，返回购买失败。

```sql
update zproduct set stock=stock-?,version=version+1 where id=? and version=?;
```

### 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

示例：

事物A（1，修改数据x；2，修改数据y）

事物B（1，修改数据y；2，修改数据x）

2个事物并发

事物A 修改完x后，等待获取数据y的锁

事物B修改y后，等待获取数据x的锁

于是产生死锁。



解决办法是：

- 查看死锁：show engine innodb status \G。
- 自动检测机制，超时自动回滚代价较小的事务（innodb_lock_wait_timeout 默认50s）。
- 人为解决，kill阻塞进程（show processlist）。
- wait for graph 等待图（主动检测）。





### 脏读幻读不可重复读

脏读是指一个事务读取到了其他事务没有提交的数据，不可重复读是指一个事务内多次根据同一个查询条件查询出来的“同一行记录的值不一样”，幻读是指一个事务内多次 根据同个条件查出来的记录行数不一样。为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别，不同隔离级别对上面问题部分或者全部做了避免。

间隙锁：解决幻读
